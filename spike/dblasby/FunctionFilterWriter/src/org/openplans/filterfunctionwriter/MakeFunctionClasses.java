package org.openplans.filterfunctionwriter;



import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.lang.reflect.Method;
import java.util.Collection;





import com.vividsolutions.jts.operation.polygonize.Polygonizer;

import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryCollection;

import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.MultiLineString;
import com.vividsolutions.jts.geom.MultiPoint;
import com.vividsolutions.jts.geom.MultiPolygon;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.Polygon;
import com.vividsolutions.jts.io.WKTReader;

/**
 *  Basic idea:
 * 
 *    1. for each method in the StaticGeometry class (or whatever class you specify - see main() )
 *    2.       make a .java file
 *                   * put the header in (ie. includes, etc...)
 *                   * put the actual code in (see "emit()" below)
 *                   * put the footer in (ie. finish the class "}")
 * 
 * @author dblasby
 */
public class MakeFunctionClasses
{

	public static void main(String[] args)
	{	
		MakeFunctionClasses cg = new MakeFunctionClasses();
		
		cg.handleClass(org.geotools.filter.function.StaticGeometry.class);  // parent of all geometry types
	}
	
	  public void handleClass(Class c)
	    {
	    	Method[] methods = c.getDeclaredMethods();
			for (int t=0;t<methods.length;t++)
			{
				try{
					Method method = methods[t];
					File f = new File ("src/org/geotools/filter/function/FilterFunction_"+method.getName()+".java");
					PrintStream ps = new PrintStream( new FileOutputStream(f));
					
					emitHeader(method,ps);		
						emitCode(method,ps);
					emitFooter(method,ps);
					
					ps.close();
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
			}
	    }
	  
	    public void emitHeader(Method m,PrintStream printstream)
  		{
			printstream.println("package org.geotools.filter.function;");
			printstream.println("");
			printstream.println("");
			printstream.println("//this code is autogenerated - you shouldnt be modifying it!");
			printstream.println("");
			printstream.println("import com.vividsolutions.jts.geom.*; //generic JTS support");
			printstream.println("import org.geotools.filter.function.StaticGeometry; //make sure you include this or you will not be able to call the functions!!");
			printstream.println("");
			printstream.println("");
			
			printstream.println("import org.geotools.feature.Feature;");
			printstream.println("import org.geotools.filter.Expression;");
			printstream.println("import org.geotools.filter.FilterFactory;");
			printstream.println("import org.geotools.filter.FunctionExpression;");
			printstream.println("import org.geotools.filter.FunctionExpressionImpl;");
			printstream.println("import org.geotools.filter.LiteralExpression;");
			printstream.println("");
			printstream.println("");
			printstream.println("public class "+"FilterFunction_"+m.getName() +" extends FunctionExpressionImpl implements FunctionExpression ");
			printstream.println("{");		
			printstream.println("");
			printstream.println("");
			printstream.println("private Expression[] args; // list of args that this functions needs");
			printstream.println("");
			printstream.println("");
			printstream.println("public FilterFunction_"+m.getName()+"()");
			printstream.println("{");
			printstream.println("}");
			printstream.println("");
			printstream.println("");
			printstream.println("public String getName()");
			printstream.println("{");
			printstream.println("      return \""+m.getName()+"\";");
			printstream.println("}");
			printstream.println("");
			printstream.println("public int getArgCount()");
			printstream.println("{");
			printstream.println("      return "+m.getParameterTypes().length+";");
			printstream.println("}");
			printstream.println("");
			printstream.println("public void setArgs(Expression[] args)");
			printstream.println("{");
			printstream.println("      this.args = args;");
			printstream.println("}");
			printstream.println("");
			printstream.println("public Expression[] getArgs()");
			printstream.println("{");
			printstream.println("       return args;");
			printstream.println("}");
			printstream.println("");
			printstream.println("public String toString()");
			printstream.println("{");
			printstream.println("       String result =  \""+m.getName()+"(\";");
			printstream.println("       for (int t=0;t<args.length;t++)" );
			printstream.println("       {");
			printstream.println("                result += args[t] +\",\";");
			printstream.println("       }");
			printstream.println("       result += \")\";");
			printstream.println("       return result;");
			printstream.println("}");
			printstream.println("");
  		}
	  
	    public void emitFooter(Method m,PrintStream printstream)
  		{
	    	printstream.println("}");
	    	printstream.println("");
  		}
	    
	  
	  public void emitCode(Method m,PrintStream printstream)
		{
			printstream.println("public Object getValue(Feature feature)");
			printstream.println("{");
			
			//variable decs
			for (int t=0;t<m.getParameterTypes().length;t++)
			{
				printstream.println("      "+formatClassName(m.getParameterTypes()[t]) + "  arg"+t +";");
			}
			
			printstream.println("");
			printstream.println("");
			//assignments
			for (int t=0;t<m.getParameterTypes().length;t++)
			{
				printstream.println("      try{  //attempt to get value and perform conversion");
				printstream.print  ("                arg"+t+" = ");
				if (isNumber(m.getParameterTypes()[t]))
				{
					if ( (m.getParameterTypes()[t] == int.class)  )
					{
						printstream.println  ("((Number) args["+t+"].getValue(feature)).intValue();");
					}
					else if ( (m.getParameterTypes()[t] == double.class)  )
					{
						printstream.println  ("((Number) args["+t+"].getValue(feature)).doubleValue();");
					}
					else throw new IllegalArgumentException("dont know how to handle this - "+m.getParameterTypes()[t]);
					
				}
				else if ( (m.getParameterTypes()[t] == boolean.class)  )
				{
					printstream.println  ("((Boolean) args["+t+"].getValue(feature)).booleanValue();");
				}
				else if ( (m.getParameterTypes()[t] == String.class)  )
				{
					printstream.println  ("(args["+t+"].getValue(feature)).toString(); // extra protection for strings");
				}
				else //class
				{
					printstream.println("("+formatClassName(m.getParameterTypes()[t])+") args["+t+"].getValue(feature);");
				}
				printstream.println("      }");
				printstream.println("      catch (Exception e) // probably a type error");
				printstream.println("      {");
				printstream.println("            throw new IllegalArgumentException(\"Filter Function problem for function "+m.getName()+" argument #"+t+" - expected type "+formatClassName(m.getParameterTypes()[t])+"\");");
				printstream.println("      }");
				printstream.println("");
			}
			
			//perform computation
			
			if (isNumber(m.getReturnType() ))
			{
				if (m.getReturnType() == int.class)
					printstream.print  ("      return new Integer(StaticGeometry."+ m.getName()+"(" );
				if (m.getReturnType() == double.class)
					printstream.print  ("      return new Double(StaticGeometry."+ m.getName()+"(" );
			}
			else if (m.getReturnType() == boolean.class)
			{
				printstream.print  ("      return new Boolean(StaticGeometry."+ m.getName()+"(" );
			}
			else //class
			{
				printstream.print  ("      return (StaticGeometry."+m.getName()+"(");
			}
			
			for (int t=0;t<m.getParameterTypes().length;t++)
			{
				if (t != 0)
					printstream.print(",");
				printstream.print("arg"+(t));			
			}
			printstream.println(" ));");
			
			
			printstream.println("}");
			
		}
		
		/**
	 * @param class1
	 * @return
	 */
	private boolean isNumber(Class class1) 
	{
		if  ( (class1 == int.class)  || (class1 == double.class) )
		{
			return true;
		}
		return false;
	}

		public String formatClassName(Class c)
		{
			String fullName = c.getName();
			int indx = fullName.lastIndexOf('.');
			if (indx ==-1)
				return fullName;
			else
				return fullName.substring(indx+1);
			
		}
		
		
	

}


