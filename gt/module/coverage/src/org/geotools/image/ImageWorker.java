/*
 * Geotools 2 - OpenSource mapping toolkit
 * (C) 2006, Geotools Project Managment Committee (PMC)
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.geotools.image;

// J2SE dependencies
import java.awt.Image;
import java.awt.Dimension;
import java.awt.Transparency;
import java.awt.RenderingHints;
import java.awt.image.*;
import java.awt.color.ColorSpace;
import java.util.Arrays;

// Image I/O and JAI dependencies
import javax.media.jai.*;
import javax.media.jai.operator.*;
import com.sun.media.jai.util.ImageUtil;
import com.sun.media.jai.operator.ImageReadDescriptor;

// Geotools dependencies
import org.geotools.resources.Utilities;
import org.geotools.resources.i18n.Errors;
import org.geotools.resources.i18n.ErrorKeys;
import org.geotools.resources.image.ColorUtilities;
import org.geotools.resources.image.ImageUtilities;


/**
 * Helper methods for applying JAI operations on an image. The image is specified at
 * {@linkplain #ImageWorker(RenderedImage) creation time}. Sucessive operations can
 * be applied by invoking the methods defined in this class, and the final image can
 * be obtained by invoking {@link #getRenderedImage} at the end of the process.
 * 
 * 
 * @author Martin Desruisseaux
 * @author Simone Giannecchini
 * @author Bryce Nordgren
 * @version $Id$
 * @since 2.3
 * @source $URL$
 */
public class ImageWorker {
    /**
     * The image property name generated by {@link ExtremaDescriptor}.
     */
    private static final String EXTREMA = "extrema";

    /**
     * The image specified by the user at construction time.
     */
    private final RenderedImage original;

    /**
     * The image being built, or {@code null} if none.
     */
    protected RenderedImage image;

    /**
     * Whatever the image should be cached, as a rendering hint.
     */
    private RenderingHints extraHints;

    /**
     * Creates a new builder for the specified image. The images to be computed (if any)
     * will save their tiles in the default {@linkplain TileCache tile cache}.
     *
     * @param image The source image.
     */
    public ImageWorker(final RenderedImage image) {
        this.original = this.image = image;
    }

    /**
     * Returns the current {@linkplain #image}.
     */
    public RenderedImage getRenderedImage() {
        return image;
    }

    /**
     * Returns a {@linkplain ROI Region Of Interest} built from the current {@linkplain #image}.
     * If the image is multi-bands, then this method first computes an estimation of its
     * {@linkplain #retainIntensityBand intensity}. Next, this method {@linkplain #binarize
     * binarize} the image and constructs a {@link ROI} from the result.
     * <p>
     * Note that invoking this method change the current state of {@link #image}.
     */
    public ROI getROI(final double threshold) {
        retainIntensityBand();
        binarize(threshold);
        return new ROI(image);
    }

    /**
     * Set the tile cache to use for all images to be computed by this class. This method applies
     * only to the next images to be computed; images already computed before this method call (if
     * any) will not be affected. A {@code null} value disable completly the tile cache.
     */
    public void setTileCache(final TileCache cache) {
        if (extraHints == null) {
            extraHints = new RenderingHints(null);
        }
        extraHints.put(JAI.KEY_TILE_CACHE, cache);
    }

    /**
     * Unset any tile cache specified by {@link #setTileCache}. All images to be computed after
     * this method call will save their tiles in the {@linkplain #JAI#getTileCache JAI default
     * tile cache}.
     */
    public void unsetTileCache() {
        if (extraHints != null) {
            extraHints.remove(JAI.KEY_TILE_CACHE);
        }
    }

    /**
     * Returns the rendering hints for an image to be computed by this class. By default, the only
     * hints provided (if any) are relative to tile width, tile height and tile cache. Subclasses
     * can override this method if they want to extend those rendering hints.
     *
     * @return The rendering hints to use for image computation (never {@code null}).
     */
    protected RenderingHints getRenderingHints() {
        RenderingHints hints = ImageUtilities.getRenderingHints(image);
        if (hints == null) {
            return new RenderingHints(extraHints);
        }
        if (extraHints != null) {
            hints.putAll(extraHints);
        }
        return hints;
    }

    /**
     * Returns the {@linkplain #getRenderingHints rendering hints}, but with a
     * {@linkplain ComponentColorModel component color model} of the specified
     * data type. The data type is changed only if no color model was explicitly
     * specified by the user through {@link #getRenderingHints()}.
     *
     * @param type The data type (typically {@link DataBuffer#TYPE_BYTE}).
     */
    private RenderingHints getRenderingHints(final int type) {
        /*
         * Get the default hints, which usually contains only informations about tiling.
         * If the user overrided the rendering hints with an explict color model, keep
         * the user's choice.
         */
        final RenderingHints hints = getRenderingHints();
        ImageLayout layout = (ImageLayout) hints.get(JAI.KEY_IMAGE_LAYOUT);
        if (layout == null) {
            layout = new ImageLayout();
        } else if (layout.isValid(ImageLayout.COLOR_MODEL_MASK)) {
            return hints;
        }
        /*
         * Creates the new color model.
         *
         * TODO: Please explain why the ColorSpace is forced to CS_sRGB? This behavior seems
         *       to be required by rescaleToBytes and forceComponentColorModel, but why?
         */
        ColorModel cm = image.getColorModel();
        cm = new ComponentColorModel(
                ColorSpace.getInstance(ColorSpace.CS_sRGB),
                cm.hasAlpha(),              // If true, supports transparency.
                false,                      // If true, alpha is premultiplied.
                cm.getTransparency(),       // What alpha values can be represented.
                type);                      // Type of primitive array used to represent pixel.
        /*
         * Creating the final image layout which should allow us to change color model.
         */
        layout.setColorModel(cm);
        layout.setSampleModel(cm.createCompatibleSampleModel(image.getWidth(), image.getHeight()));
        hints.put(JAI.KEY_IMAGE_LAYOUT, layout);
        return hints;
    }

    /**
     * Gets a property from the property set of the {@linkplain #image}. If the property name
     * is not recognized, then {@link Image#UndefinedProperty} will be returned. This method
     * do <strong>not</strong> inherits properties from the image specified at
     * {@linkplain #ImageWorker(RenderedImage) construction time} - only properties generated
     * by this class are returned.
     */
    private Object getComputedProperty(final String name) {
        final Object value = image.getProperty(name);
        return (value == original.getProperty(name)) ? Image.UndefinedProperty : value;
    }

    /**
     * Returns the minimums and maximums values found in the image. Those extremas are
     * returned as an array of the form {@code double[2][#bands]}.
     */
    private double[][] getExtremas() {
        Object extrema = getComputedProperty(EXTREMA);
        if (!(extrema instanceof double[][])) {
            image = ExtremaDescriptor.create(
                    image,  // The source image.
                    null,   // The region of the image to scan. Default to all.
                    null,   // The horizontal sampling rate. Default to 1.
                    null,   // The vertical sampling rate. Default to 1.
                    null,   // Whether to store extrema locations. Default to false.
                    null,   // Maximum number of run length codes to store. Default to 1.
                    null);  // The rendering hints.
        }
        return (double[][]) extrema;
    }

    /**
     * Tells this builder that the "extrema" property in the specified image should not be
     * inherited from the source images (if any).
     */
    private static void invalidateRanges(final WritablePropertySource image) {
        image.setProperty(EXTREMA, null);
    }

    /**
     * Rescales the {@linkplain #image} such that it uses 8 bits. This method computes the minimum
     * and maximum values for each band, {@linkplain RescaleDescriptor rescale} them in the range
     * {@code [0 .. 255]} and force the resulting image to {@link DataBuffer#TYPE_BYTE TYPE_BYTE}.
     */
    public void rescaleToBytes() {
        if (image.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE) {
            // Already using bytes - nothing to do.
            return;
        }
        if (image.getColorModel() instanceof IndexColorModel) {
            throw new UnsupportedOperationException(
                    "Rescaling not yet implemented for IndexColorModel.");
        }
        final double[][] extrema = getExtremas();
        final int length = extrema[0].length;
        final double[] scale  = new double[length];
        final double[] offset = new double[length];
        for (int i=0; i<length; i++) {
            final double delta = extrema[1][i] - extrema[0][i];
            scale [i] = 255 / delta;
            offset[i] = -scale[i] * extrema[0][i];
        }
        final RenderingHints hints = getRenderingHints(DataBuffer.TYPE_BYTE);
        final RenderedOp  rescaled = RescaleDescriptor.create(
                image,      // The source image.
                scale,      // The per-band constants to multiply by.
                offset,     // The per-band offsets to be added.
                hints);     // The rendering hints.

        invalidateRanges(rescaled); // Extremas are no longer valid.
        image = rescaled;
    }

    /**
     * Reduces the color model to index color model. The current implementation should work
     * only for RGB since it performs a ditering on the original color model.
     */
    public void forceIndexColorModel() {
        final ColorModel cm = image.getColorModel();
        if (cm instanceof IndexColorModel) {
            // Already an index color model - nothing to do.
            return;
        }
        if (cm.getColorSpace().getType() != ColorSpace.TYPE_RGB) {
            throw new UnsupportedOperationException("Implemented for RGB type only.");
        }
        // error dither
        final KernelJAI[]    ditherMask = KernelJAI.DITHER_MASK_443;
        final ColorCube      colorMap   = ColorCube.BYTE_496;
        final RenderingHints hints      = getRenderingHints();
        image = OrderedDitherDescriptor.create(image, colorMap, ditherMask, hints);
    }

	/**
	 * Reformats the {@linkplain ColorModel color model} to a {@linkplain ComponentColorModel
     * component color model} preserving transparency. This is used especially in order to go
     * from {@link PackedColorModel} to {@link ComponentColorModel}, which seems to be well
     * accepted from {@code PNGEncoder} and {@code TIFFEncoder}.
     * <p>
     * This code is adapted from jai-interests mailing list archive.
	 */
    public void forceComponentColorModel() {
        final ColorModel cm = image.getColorModel();
        if (cm instanceof ComponentColorModel) {
            // Already an component color model - nothing to do.
            return;
        }
        final int type = image.getSampleModel().getTransferType();
        // Most of the code is adapted from jai-interests is in 'getRenderingHints(int)'.
        final RenderingHints hints = getRenderingHints((cm instanceof DirectColorModel) ?
                                                        DataBuffer.TYPE_BYTE : type);
        image = FormatDescriptor.create(image, new Integer(type), hints);
	}

    /**
     * Retains only one band of {@linkplain #image} which represents approximatively the intensity.
     * If the image uses an {@linkplain IHSColorSpace IHS color space}, then this method just
     * {@linkplain #retainFirstBand retain the first band} without any further processing.
     * Otherwise, this method performs a simple {@linkplain BandCombineDescriptor band combine}
     * operation on the {@linkplain #image} in order to come up with a simple estimation of the
     * intensity of the image based on the average value of the color components. It is worthwhile
     * to note that the alpha band is stripped from the image.
     */
    public void retainIntensityBand() {
        /*
         * If the color model already use a IHS color space, keep only the intensity band.
         * Otherwise, we need a component color model to be sure to understand what we are doing.
         */
        ColorModel cm = image.getColorModel();
        final ColorSpace cs = cm.getColorSpace();
        if (cs.getType()==ColorSpace.TYPE_GRAY || cs instanceof IHSColorSpace) {
            retainFirstBand();
            return;
        }
        if (cm instanceof IndexColorModel) {
            forceComponentColorModel();
            cm = image.getColorModel();
        }

        // Number of color componenents
        final int numBands      = cm.getNumComponents();
        final int numColorBands = cm.getNumColorComponents();
        final boolean hasAlpha  = cm.hasAlpha();

        // One band, nothing to combine.
        if (numBands == 1) {
            return;
        }
        // One band plus alpha, let's remove alpha.
        if (numColorBands == 1 && hasAlpha) {
            retainFirstBand();
            return;
        }
        /*
         * We have more than one band. Note that there is no need to remove the alpha band before
         * to apply the "bandCombine" operation - it is suffisient to let the coefficient for the
         * alpha band to the 0 value.
         */
        final double[][] coeff = new double[1][numBands + 1];
        Arrays.fill(coeff[0], 0, numColorBands, 1.0/numColorBands);
        image = BandCombineDescriptor.create(image, coeff, getRenderingHints());
    }

    /**
     * Retains inconditionnaly the first band of {@linkplain #image}.
     * All other bands (if any) are discarted without any further processing.
     */
    public void retainFirstBand() {
        final SampleModel sm = image.getSampleModel();
        if (sm.getNumBands() != 1) {
            // Note: we don't use 'getRenderingHints()' because we don't want to set any
            //       tiling, since we don't want to force a copy of all pixel values.
            image = BandSelectDescriptor.create(image, new int[] {0}, extraHints);
        }
    }

    /**
     * Binarizes the {@linkplain #image}.
     *
     * @param threshold The threshold value.
     */
    public void binarize(final double threshold) {
        // If the image is already binary and the threshold is >1 then there is no work to do.
        if ((threshold < 1) || !ImageUtil.isBinary(image.getSampleModel())) {
            final RenderingHints hints = getRenderingHints();
            image = BinarizeDescriptor.create(image, new Double(threshold), hints);
        }
    }
}
