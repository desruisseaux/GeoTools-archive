<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <TITLE>package org.geotools.display.canvas</TITLE>
  </HEAD>
  <BODY>
    Geotools implementation of GO-1 Canvas. An
    explanation for this package is provided in the {@linkplain org.opengis.go.display.canvas OpenGIS&reg; javadoc}.
    The remaining discussion on this page is specific to the Geotools implementation.

    <P ALIGN="justify">A {@linkplain org.geotools.display.canvas.BufferedCanvas2D canvas} contains one ore more
    {@linkplain org.geotools.display.primitive.GraphicPrimitive2D graphic} objects. A graphic object may wrap
    an image, a geometric shape, a collection of symbols, <cite>etc.</cite> Since this package can't cover
    all possible usages, most of the classes provided in {@link org.geotools.display.canvas} and in
    {@link org.geotools.display.primitive} packages are designed with subclassing in mind. The design has
    some similarities with AWT graphic components. The following is a comparaison between AWT and the
    Geotools Canvas implementation:</P>

    <P>&nbsp;</P>
    <H2>Painting with AWT</H2>

    <P ALIGN=justify>An {@linkplain java.awt.Container AWT container} contains an arbitrary amount of
    {@linkplain java.awt.Component components}. Each component (button, scrolling bar, <cite>etc.</cite>)
    is implemented by a specialized subclass ({@link java.awt.Button}, {@link java.awt.Scrollbar}, <cite>etc.</cite>)
    extending {@link java.awt.Component}. When the rendering engine needs to repaint a component, it invokes
    the component's {@link java.awt.Component#paint(java.awt.Graphics) paint(...)} method. The paint method
    receives a {@link java.awt.Graphics2D} object setup as below:</P>

    <P ALIGN="center">
    <TABLE BORDER =1 cellpadding=4>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Axis origin (0,0):</TH>
        <TD bgcolor=lightgoldenrodyellow>Screen or paper Upper Left corner.</TD>
      </TR>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Axis directions:</TH>
        <TD bgcolor=lightgoldenrodyellow><var>x</var> values increasing right
            and <var>y</var> values increasing <strong><U>down</U></strong>.</TD>
      </TR>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Axis units:</TH>
        <TD bgcolor=lightgoldenrodyellow>Pixels or points (about 1/72 of inch).</TD>
      </TR>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Line width:</TH>
        <TD bgcolor=lightgoldenrodyellow>One pixel or one point (1/72 of inch).</TD>
      </TR>
    </TABLE>

    <P ALIGN=justify>This configuration is appropriate for text rendering. A font may
    be 12 points high, which usually means 12 pixels on a screen output device or 1/6
    of inch on a paper. The {@code paint(...)} method may apply temporary changes to the
    {@link java.awt.Graphics2D} configuration, but may rollback {@code Graphics2D} to its
    inital state before to return.</P>

    <P>&nbsp;</P>
    <H2>Painting with {@code Canvas} (compared to AWT)</H2>

    <P ALIGN="justify">A {@link org.geotools.display.canvas.BufferedCanvas2D} object contains a set of
    {@link org.geotools.display.primitive.GraphicPrimitive2D} objects. Every kind of graphic primitive
    (image, polygon...) is handled by a specialized subclass ({@link org.geotools.display.primitive.GraphicImage2D},
    {@link org.geotools.display.primitive.GraphicPolygon2D}, <cite>etc.</cite>) extending
    {@link org.geotools.display.primitive.GraphicPrimitive2D}. When the rendering engine need to repaint
    a graphic, it invokes its {@link org.geotools.display.primitive.GraphicPrimitive2D#paint paint(...)}
    method. The paint method receives a {@link java.awt.Graphics2D} object setup as below:</P>

    <P ALIGN="center">
    <TABLE BORDER =1 cellpadding=4>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Axis origin (0,0):</TH>
        <TD bgcolor=lightgoldenrodyellow>Objective CRS dependent.
        Often outside the displayed area.</TD>
      </TR>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Axis directions:</TH>
        <TD bgcolor=lightgoldenrodyellow>Objective CRS dependent.
        Usually <var>x</var> values increasing right and <var>y</var> values
        increasing <strong><U>up</U></strong>, like classical geometry.</TD>
      </TR>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Axis units:</TH>
        <TD bgcolor=lightgoldenrodyellow>Objective CRS dependent.
        Usually "real world" meters (not meters on the output device!),
        sometime longitude and latitude degrees.</TD>
      </TR>
      <TR>
        <TH ALIGN="right" bgcolor=bisque nowrap>Line width:</TH>
        <TD bgcolor=lightgoldenrodyellow>Map resolution dependent.
        May be 50 "real world" meters for example.</TD>
      </TR>
    </TABLE>

    <P ALIGN="justify">This configuration is convenient for rendering "real world" objects.
    The {@code GraphicPrimitive2D} implementor doesn't need to care about the zoom factor.
    However, this configuration is unconvenient for text or symbols rendering. For example
    a font with a size of 12 units will be understood as a 12 meters high font. On a map
    with a 1:50000 scale, 12 meters high characters will appear like tiny points. In such
    cases, the {@code Graphic} implementor need to setup explicitly the {@link java.awt.Graphics2D}
    object as in "Painting with AWT" above. Don't forget to reset the {@code GraphicsPrimitive2D}
    in its initial state once finished.</P>

    <p>&nbsp;</p>
    <h2>Affine transform tips</h2>

    <P align="justify"><cite>Java2D</cite> converts "real world" coordinates into a output
    device coordinates using an instance of the {@link java.awt.geom.AffineTransform} object.
    An affine transform can be represented as a 3&times;3 matrix. Using the appropriate coefficients,
    one can apply any combinations of scale, translation, rotation and shear. The equation below
    assumes that input coordinates are in meters and output in pixel units, but the same equation
    can be used with most units:</P>

    <P ALIGN="center"><IMG src="doc-files/AffineTransform.png"></P>

    <P align=justify>The {@link java.awt.geom.AffineTransform} class provides a set of methods
    for changing an affine transform without worrying about the underlying mathematic. For
    example the {@code rotate(...)} method modifies the coefficients of the 3&times;3 matrix
    in order to add a rotation effect given a simple angle in radians. In the context of map
    rendering, there is a useful identity not mentioned in the class javadoc:</P>

    <P ALIGN="center"><IMG src="doc-files/scaleX0.png"> and
                      <IMG src="doc-files/scaleY0.png"> are unvariant under rotations.</P>

    <P align=justify>If there is no rotation and no shear, then the
    <var>m</var><SUB>01</SUB> and <var>m</var><SUB>10</SUB> coefficients are null. The remaining
    <var>m</var><SUB>00</SUB> and <var>m</var><SUB>11</SUB> coefficient give us the map scale among
    <var>x</var> and <var>y</var> axis respectively. In this simple case, the usual {@code getScaleX()}
    and {@code getScaleY()} methods work.:</P>

    <P ALIGN="center"><IMG src="doc-files/scaleX0.png">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>m</var><SUB>00</SUB>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE>AffineTransform.getScaleX()</CODE></P>
    <P ALIGN="center"><IMG src="doc-files/scaleY0.png">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>m</var><SUB>11</SUB>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE>AffineTransform.getScaleY()</CODE></P>

    <P align=justify>But if there is a rotation (but no shear), then the {@code getScaleX()} and
    {@code getScaleY()} methods do not work anymore. We need to use the relationships on the left
    side. Note that those relationships do not work neither in the presence of shear. But because
    the default Geotools {@code Canvas} implementation uses only scales, rotations and translations
    (no shear), implementors are encouraged to use the relationships on the left side all the time
    instead of the ordinary {@code getScaleX()} and {@code getScaleY()} methods. This is especially
    important since may "real world" coordinate systems swap their axis order (e.g. use
    (<var>latitude</var>, <var>longitude</var>) values instead of (<var>longitude</var>, <var>latitude</var>)
    values), which is similar to a rotation. {@code Graphic} implementations relying only on the ordinary
    {@code getScaleX()} and {@code getScaleY()} methods may fail to render a map in such coordinate systems.</P>
  </BODY>
</HTML>
